// 标签：栈

/**
 * 
 * 
 * 
 * 给你一个括号字符串 s ，它只包含字符 '(' 和 ')' 。一个括号字符串被称为平衡的当它满足：

  任何左括号 '(' 必须对应两个连续的右括号 '))' 。
  左括号 '(' 必须在对应的连续两个右括号 '))' 之前。
  比方说 "())"， "())(())))" 和 "(())())))" 都是平衡的， ")()"， "()))" 和 "(()))" 都是不平衡的。

  你可以在任意位置插入字符 '(' 和 ')' 使字符串平衡。

  请你返回让 s 平衡的最少插入次数。

   

  示例 1：

  输入：s = "(()))"
  输出：1
  解释：第二个左括号有与之匹配的两个右括号，但是第一个左括号只有一个右括号。我们需要在字符串结尾额外增加一个 ')' 使字符串变成平衡字符串 "(())))" 。
  示例 2：

  输入：s = "())"
  输出：0
  解释：字符串已经平衡了。
  示例 3：

  输入：s = "))())("
  输出：3
  解释：添加 '(' 去匹配最开头的 '))' ，然后添加 '))' 去匹配最后一个 '(' 。
  示例 4：

  输入：s = "(((((("
  输出：12
  解释：添加 12 个 ')' 得到平衡字符串。
  示例 5：

  输入：s = ")))))))"
  输出：5
  解释：在字符串开头添加 4 个 '(' 并在结尾添加 1 个 ')' ，字符串变成平衡字符串 "(((())))))))" 。
   

  提示：

  1 <= s.length <= 10^5
  s 只包含 '(' 和 ')' 。

  来源：力扣（LeetCode）
  链接：https://leetcode-cn.com/problems/minimum-insertions-to-balance-a-parentheses-string
  著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */




/**
 * 思路：
 * 从左向右一次遍历
 * 
 * 1. 遍历
 *  1-1. 维护「左括号计数器」left，遇到左括号就自增+1.
 *  2-1. 遇到右括号
 *   2-1-1. left为0，则ans++
 *   2-1-2. left不为0，left--
 *   2-1-3. 下一个字符不是右括号，那么ans++
 *   2-1-4. 下一个字符是右括号，ans按兵不动，i++
 * 2. left 有剩余，将答案加上 left * 2，无剩余也不影响答案
 * 
 */

 /**
  * 
  * @param {String} s
  * 
  *  时间复杂度：O(n)
  *  空间复杂度：O(1)
  */
function minInsertions(s: string): number {
  const n = s.length - 1
  let left = 0, ans = 0
  // 1.
  for (let i = 0; i <= n; i++ ) {
    if (s.charAt(i) === '(') {
      left++
    } else {
      if (left === 0) {
        ans++
      } else {
        left--
      }

      if (i === n || s.charAt(i + 1) !== ')') {
        ans++
      } else {
        i++
      }
    }
  }
  // 2. 和left作匹配
  ans += left * 2
  return ans 
};